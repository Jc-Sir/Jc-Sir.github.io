(window.webpackJsonp=window.webpackJsonp||[]).push([[189],{756:function(t,h,s){"use strict";s.r(h);var a=s(25),v=Object(a.a)({},(function(){var t=this,h=t.$createElement,s=t._self._c||h;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"文件指纹"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件指纹"}},[t._v("#")]),t._v(" 文件指纹")]),t._v(" "),s("ul",[s("li",[t._v("打包后输出的文件名和后缀")]),t._v(" "),s("li",[t._v("hash一般是结合CDN缓存来使用，通过webpack构建之后，生成对应文件名自动带上对应的MD5值。如果文件内容改变的话，那么对应文件哈希值也会改变，对应的HTML引用的URL地址也会改变，触发CDN服务器从源服务器上拉取对应数据，进而更新本地缓存。")])]),t._v(" "),s("h2",{attrs:{id:"文件指纹如何生成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件指纹如何生成"}},[t._v("#")]),t._v(" 文件指纹如何生成")]),t._v(" "),s("ul",[s("li",[t._v("Hash 是整个项目的hash值，其根据每次编译内容计算得到，每次编译之后都会生成新的hash,即修改任何文件都会导致所有文件的hash发生改变，在一个项目中虽然入口不同，但是hash是相同的，hash无法实现前端静态资源的浏览器长缓存，如果有这个需求应该使用chunkhash")]),t._v(" "),s("li",[t._v("chunkhash 采用hash计算的话，每一次构建后生成的哈希值都不一样，即使文件内容压根没有改变。这样子是没办法实现缓存效果，我们需要换另一种哈希值计算方式，即chunkhash,chunkhash和hash不一样，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响")]),t._v(" "),s("li",[t._v("contenthash 使用chunkhash存在一个问题，就是当在一个JS文件中引入CSS文件，编译后它们的hash是相同的，而且只要js文件发生改变 ，关联的css文件hash也会改变,这个时候可以使用mini-css-extract-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建")])]),t._v(" "),s("h2",{attrs:{id:"指纹占位符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#指纹占位符"}},[t._v("#")]),t._v(" 指纹占位符")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("占位符名称")]),t._v(" "),s("th",[t._v("含义")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("ext")]),t._v(" "),s("td",[t._v("资源后缀名")])]),t._v(" "),s("tr",[s("td",[t._v("name")]),t._v(" "),s("td",[t._v("文件名称")])]),t._v(" "),s("tr",[s("td",[t._v("path")]),t._v(" "),s("td",[t._v("文件的相对路径")])]),t._v(" "),s("tr",[s("td",[t._v("folder")]),t._v(" "),s("td",[t._v("文件所在的文件夹")])]),t._v(" "),s("tr",[s("td",[t._v("contenthash")]),t._v(" "),s("td",[t._v("文件的内容hash,默认是md5生成")])]),t._v(" "),s("tr",[s("td",[t._v("hash")]),t._v(" "),s("td",[t._v("文件内容的hash,默认是md5生成")])]),t._v(" "),s("tr",[s("td",[t._v("emoji")]),t._v(" "),s("td",[t._v("一个随机的指代文件内容的emoj")])])])])])}),[],!1,null,null,null);h.default=v.exports}}]);