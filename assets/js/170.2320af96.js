(window.webpackJsonp=window.webpackJsonp||[]).push([[170],{733:function(t,e,a){"use strict";a.r(e);var c=a(25),r=Object(c.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"computed-和-watch-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-的区别"}},[t._v("#")]),t._v(" computed 和 watch 的区别")]),t._v(" "),a("h2",{attrs:{id:"computed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),a("ul",[a("li",[t._v("computed 是计算属性,也就是计算值,它更多用于计算值的场景")]),t._v(" "),a("li",[t._v("computed 具有缓存性,computed 的值在 getter 执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取 computed 的值时才会重新调用对应的 getter 来计算")]),t._v(" "),a("li",[t._v("computed 适用于计算比较消耗性能的计算场景")])]),t._v(" "),a("h2",{attrs:{id:"watch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")]),t._v(" "),a("ul",[a("li",[t._v("更多的是「观察」的作用,类似于某些数据的监听回调,用于观察 props \\ $emit 或者本组件的值,当数据变化时来执行回调进行后续操作")]),t._v(" "),a("li",[t._v("无缓存性，页面重新渲染时值不变化也会执行")])]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("ul",[a("li",[t._v("当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为 computed")]),t._v(" "),a("li",[t._v("如果你需要在某个数据变化时做一些事情，使用 watch 来观察这个数据变化")])])])}),[],!1,null,null,null);e.default=r.exports}}]);